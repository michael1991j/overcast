// OVERCAST engine created by Michael Roberts
// THIS IS AUTOGENERATED CODE DO NOT MAKE CHANGES

import * as mssql from "mssql";
import {
    createQuery,
    createFilter
} from "odata-v4-mssql";
import {
    ODataController,
    Edm,
    odata,
    ODataQuery
} from "odata-v4-server";
import {
    Overcast
} from "overcast";
import {
    config
} from "../../config";
import {
    SensorBox
} from "../../Models/SensorBox/SensorBox";

import {
    Sensor
} from "../../Models/Sensor/Sensor";

import {
    Measurement
} from "../../Models/Measurement/Measurement";


export class SensorControllerAutoGen extends ODataController {

    @odata.GET
    async findOne(@odata.key id: string, @odata.stream stream: any, @odata.query query: ODataQuery): Promise < Sensor > {
        const request = await Overcast.request(config);
        const sqlQuery = createQuery(query);
        sqlQuery.parameters.forEach((value: any, name: any) => request.input(name, value));
        request.input("id", id);
        let result;
        try {
            result = await request.query(`SELECT ${sqlQuery.select} FROM Sensor WHERE SensorUID = @id AND (${sqlQuery.where})`);

        } catch (error) {
            console.log(error);
            const newrequest = Overcast.newRequest(config);

        }
        return result.recordsets[0][0];

    }
    @odata.GET
    async find(@odata.stream stream: any, @odata.query query: ODataQuery): Promise < Sensor[] | void > {
        const request = await Overcast.request(config);
        const sqlQuery = createQuery(query);
        sqlQuery.parameters.forEach((value: any, name: any) => request.input(name, value));
        let result = await request.query(sqlQuery.from("Sensor"));

        return result.recordsets[0];
    }
    @odata.POST
    async insert(@odata.body data: any): Promise < Sensor > {
        const request = await Overcast.request(config);
        const columns = Object.keys(data);
        const values = Object.keys(data).map(key => Overcast.getConvertedValue(data[key]));
        const sqlCommand = `INSERT INTO Sensor (${columns.join(", ")}) OUTPUT inserted.* VALUES (${values.join(", ")});`;
        let result;
        try {
            result = await request.query(sqlCommand);
        } catch (error) {
            console.log(error);
            const newrequest = Overcast.newRequest(config);

        }
        return data;
    }
    @odata.PATCH
    async update(@odata.key id: string, @odata.body delta: any): Promise < number > {
        const request = await Overcast.request(config);
        const sets = Object.keys(delta).map(key => key + "=" + Overcast.getConvertedValue(delta[key]));
        const sqlCommand = `DECLARE @impactedId INT;
    UPDATE Sensor SET ${sets.join(", ")}, @impactedId = Id WHERE  SensorUID = '${id}';
    SELECT @impactedId as 'ImpactedId';`;
        const result = await request.query(sqlCommand);
        return (result) ? 1 : 0;
    }
    @odata.DELETE
    async remove(@odata.key id: string): Promise < number > {
        const request = await Overcast.request(config);
        const sqlCommand = `DELETE FROM Sensor OUTPUT deleted.* SensorUID = @id `;
        let result;
        try {
            result = await request.query(sqlCommand);
        } catch (error) {
            console.log(error);
            const newrequest = Overcast.newRequest(config);

        }
        return (Array.isArray(result.recordsets[0])) ? result.recordsets[0].length : 0;
    }
    @odata.PUT
    async overrite(@odata.key id: string, @odata.body data: any, @odata.context context: any): Promise < Sensor > {
        const request = await Overcast.request(config);
        const sqlCommandDelete = 'DELETE FROM Sensor OUTPUT deleted.* WHERE SensorUID = ${id}';
        await request.query(sqlCommandDelete);
        const product = Object.assign({}, data, {
            Id: id
        });
        const columns = Object.keys(product);
        const insertedColumns = Object.keys(product).map(key => "inserted." + key);
        const values = Object.keys(product).map(key => Overcast.getConvertedValue(product[key]));
        const sqlCommand = `SET IDENTITY_INSERT Sensor ON;
    INSERT INTO Sensor (${columns.join(", ")}) OUTPUT ${insertedColumns.join(", ")} VALUES (${values.join(", ")});
    SET IDENTITY_INSERT Sensor OFF;`;
        let result;
        result = await request.query(sqlCommand);
        return result.recordsets[0];
    }

}